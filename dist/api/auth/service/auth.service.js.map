{"version":3,"file":"auth.service.js","sourceRoot":"","sources":["../../../../src/api/auth/service/auth.service.ts"],"names":[],"mappings":";;;;;;AAAA,wDAA8B;AAG9B,4FAAmE;AACnE,mEAA+D;AAE/D,MAAa,eAAe;IACT,gBAAgB,CAAkB;IACnD,YAAY,eAAgC;QAC1C,IAAI,CAAC,gBAAgB,GAAG,eAAe,CAAC;IAC1C,CAAC;IAED,KAAK,CAAC,KAAK,CAAC,KAAa,EAAE,QAAgB;QACzC,IAAI,SAAS,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QAE/D,IAAI,CAAC,SAAS,EAAE,CAAC;YACf,MAAM,IAAI,wBAAa,CAAC,GAAG,EAAE,gBAAgB,CAAC,CAAC;QACjD,CAAC;QAED,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QAEvB,MAAM,aAAa,GAAG,QAAQ,CAAC,CAAC,yBAAyB;QACzD,MAAM,cAAc,GAAG,SAAS,CAAC,QAAQ,CAAC,CAAC,wBAAwB;QAEnE,MAAM,cAAc,GAAG,MAAM,kBAAM,CAAC,OAAO,CAAC,aAAa,EAAE,cAAc,CAAC,CAAC;QAE3E,IAAI,CAAC,cAAc,EAAE,CAAC;YACpB,MAAM,IAAI,wBAAa,CAAC,GAAG,EAAE,kBAAkB,CAAC,CAAC;QACnD,CAAC;QAED,MAAM,WAAW,GAAG,wBAAU,CAAC,mBAAmB,CAAC;YACjD,EAAE,EAAE,SAAS,CAAC,EAAE;YAChB,IAAI,EAAE,SAAS,CAAC,IAAI;YACpB,SAAS,EAAE,IAAI;SAChB,CAAC,CAAC;QAEH,OAAO,WAAW,CAAC;IACrB,CAAC;IAED,KAAK,CAAC,MAAM,KAAmB,CAAC;CACjC;AAlCD,0CAkCC","sourcesContent":["import bcrypt from \"bcryptjs\";\r\nimport { AuthService } from \"@/api/auth/service/auth.service.type\";\r\nimport { AdminRepository } from \"@/api/admin/repository/admin.repository\";\r\nimport HttpException from \"@/api/common/exceptions/http.exception\";\r\nimport { JwtService } from \"@/api/common/services/jwt.service\";\r\n\r\nexport class AuthServiceImpl implements AuthService {\r\n  private readonly _adminRepository: AdminRepository;\r\n  constructor(adminRepository: AdminRepository) {\r\n    this._adminRepository = adminRepository;\r\n  }\r\n\r\n  async login(email: string, password: string): Promise<string> {\r\n    let findEmail = await this._adminRepository.findByEmail(email);\r\n\r\n    if (!findEmail) {\r\n      throw new HttpException(404, \"존재하지 않는 회원입니다.\");\r\n    }\r\n\r\n    console.log(findEmail);\r\n\r\n    const plainPassword = password; // 사용자가 입력한 비밀번호 (일반 텍스트)\r\n    const hashedPassword = findEmail.password; // 데이터베이스에서 가져온 해싱된 비밀번호\r\n\r\n    const isSamePassword = await bcrypt.compare(plainPassword, hashedPassword);\r\n\r\n    if (!isSamePassword) {\r\n      throw new HttpException(401, \"비밀번호가 일치하지 않습니다.\");\r\n    }\r\n\r\n    const accessToken = JwtService.generateAccessToken({\r\n      id: findEmail.id,\r\n      role: findEmail.role,\r\n      expiresIn: \"7d\",\r\n    });\r\n\r\n    return accessToken;\r\n  }\r\n\r\n  async logout(): Promise<void> {}\r\n}\r\n"]}